diff --git a/drivers/lora/loramac-node/sx12xx_common.c b/drivers/lora/loramac-node/sx12xx_common.c
index 17689720dd2..85186893fc8 100644
--- a/drivers/lora/loramac-node/sx12xx_common.c
+++ b/drivers/lora/loramac-node/sx12xx_common.c
@@ -3,6 +3,9 @@
  * Copyright (c) 2020 Grinn
  *
  * SPDX-License-Identifier: Apache-2.0
+ *
+ * ZEPHCORE PATCH: Modified sx12xx_ev_rx_error() to notify async callback
+ * with NULL data on RX errors (CRC/header). This allows error counting.
  */
 
 #include <zephyr/drivers/gpio.h>
@@ -38,6 +41,12 @@ static struct sx12xx_data {
 	struct lora_modem_config tx_cfg;
 	atomic_t modem_usage;
 	struct sx12xx_rx_params rx_params;
+	/* Fast TX↔RX switching: cache last full config to detect
+	 * direction-only changes and skip redundant SPI reconfigure. */
+	struct lora_modem_config last_cfg;
+	bool last_cfg_valid;
+	bool tx_configured;   /* RadioSetTxConfig has been called with current params */
+	bool rx_configured;   /* RadioSetRxConfig has been called with current params */
 } dev_data;
 
 int __sx12xx_configure_pin(const struct gpio_dt_spec *gpio, gpio_flags_t flags)
@@ -179,6 +188,13 @@ static void sx12xx_ev_rx_error(void)
 	if (dev_data.async_rx_cb) {
 		/* Start receiving again */
 		Radio.Rx(0);
+		/*
+		 * ZEPHCORE PATCH: Notify callback with NULL data to indicate
+		 * RX error (CRC mismatch, header error). This allows the
+		 * application to count receive errors for diagnostics.
+		 */
+		dev_data.async_rx_cb(dev_data.dev, NULL, 0, 0, 0,
+				   dev_data.async_user_data);
 		/* Don't run the synchronous code */
 		return;
 	}
@@ -195,26 +211,24 @@ static void sx12xx_ev_rx_error(void)
 /**
  * @brief Convert Zephyr bandwidth enum to loramac-node bandwidth index
  *
- * The loramac-node library expects bandwidth as an index (0, 1, 2) into its
- * internal Bandwidths[] array, not the actual kHz value.
- *
- * @param bandwidth Zephyr lora_signal_bandwidth enum value
- * @param bw_idx Pointer to store the resulting bandwidth index
- * @return 0 on success, -EINVAL if bandwidth is not supported
+ * The loramac-node library expects bandwidth as an index into its internal
+ * Bandwidths[] array: {BW_007, BW_010, BW_015, BW_020, BW_031,
+ *                      BW_041, BW_062, BW_125, BW_250, BW_500}
  */
 static int sx12xx_get_bandwidth_idx(enum lora_signal_bandwidth bandwidth,
 				    uint32_t *bw_idx)
 {
 	switch (bandwidth) {
-	case BW_125_KHZ:
-		*bw_idx = 0;
-		break;
-	case BW_250_KHZ:
-		*bw_idx = 1;
-		break;
-	case BW_500_KHZ:
-		*bw_idx = 2;
-		break;
+	case BW_7_KHZ:   *bw_idx = 0; break;
+	case BW_10_KHZ:  *bw_idx = 1; break;
+	case BW_15_KHZ:  *bw_idx = 2; break;
+	case BW_20_KHZ:  *bw_idx = 3; break;
+	case BW_31_KHZ:  *bw_idx = 4; break;
+	case BW_41_KHZ:  *bw_idx = 5; break;
+	case BW_62_KHZ:  *bw_idx = 6; break;
+	case BW_125_KHZ: *bw_idx = 7; break;
+	case BW_250_KHZ: *bw_idx = 8; break;
+	case BW_500_KHZ: *bw_idx = 9; break;
 	default:
 		return -EINVAL;
 	}
@@ -225,7 +239,6 @@ uint32_t sx12xx_airtime(const struct device *dev, uint32_t data_len)
 {
 	uint32_t bw_idx;
 
-	/* Translate bandwidth to loramac-node index, default to 0 if invalid */
 	if (sx12xx_get_bandwidth_idx(dev_data.tx_cfg.bandwidth, &bw_idx) < 0) {
 		bw_idx = 0;
 	}
@@ -375,6 +388,21 @@ int sx12xx_lora_recv_async(const struct device *dev, lora_recv_cb cb, void *user
 	return 0;
 }
 
+/* Check if only the TX/RX direction changed (all radio params identical). */
+static bool sx12xx_only_direction_changed(const struct lora_modem_config *a,
+					  const struct lora_modem_config *b)
+{
+	return a->frequency == b->frequency &&
+	       a->bandwidth == b->bandwidth &&
+	       a->datarate == b->datarate &&
+	       a->coding_rate == b->coding_rate &&
+	       a->preamble_len == b->preamble_len &&
+	       a->tx_power == b->tx_power &&
+	       a->iq_inverted == b->iq_inverted &&
+	       a->public_network == b->public_network &&
+	       a->tx != b->tx;
+}
+
 int sx12xx_lora_config(const struct device *dev,
 		       struct lora_modem_config *config)
 {
@@ -388,6 +416,39 @@ int sx12xx_lora_config(const struct device *dev,
 		return ret;
 	}
 
+	/* Fast path: if only TX↔RX direction changed and the target direction
+	 * was already configured once with the same params, skip the full
+	 * RadioSetTxConfig/RadioSetRxConfig (saves ~35ms of SPI traffic).
+	 * RadioSetTxConfig MUST have been called at least once to set
+	 * TxTimeout=4000; RadioSetRxConfig MUST have been called at least
+	 * once to set PayloadLength/SymbTimeout/IQ polarity workaround. */
+	if (dev_data.last_cfg_valid &&
+	    sx12xx_only_direction_changed(config, &dev_data.last_cfg)) {
+		if (config->tx && dev_data.tx_configured) {
+			LOG_DBG("lora_config: fast TX switch (skip full reconfig)");
+			if (!modem_acquire(&dev_data)) {
+				return -EBUSY;
+			}
+			memcpy(&dev_data.tx_cfg, config, sizeof(dev_data.tx_cfg));
+			dev_data.last_cfg = *config;
+			modem_release(&dev_data);
+			return 0;
+		}
+		if (!config->tx && dev_data.rx_configured) {
+			LOG_DBG("lora_config: fast RX switch (skip full reconfig)");
+			if (!modem_acquire(&dev_data)) {
+				return -EBUSY;
+			}
+			dev_data.last_cfg = *config;
+			modem_release(&dev_data);
+			return 0;
+		}
+	}
+
+	LOG_INF("lora_config: bw_enum=%d bw_idx=%u tx=%d freq=%u sf=%d",
+		config->bandwidth, bw_idx, config->tx, config->frequency,
+		config->datarate);
+
 	/* Ensure available, decremented after configuration */
 	if (!modem_acquire(&dev_data)) {
 		return -EBUSY;
@@ -403,16 +464,21 @@ int sx12xx_lora_config(const struct device *dev,
 				  bw_idx, config->datarate,
 				  config->coding_rate, config->preamble_len,
 				  false, crc, 0, 0, config->iq_inverted, 4000);
+		dev_data.tx_configured = true;
 	} else {
 		/* TODO: Get symbol timeout value from config parameters */
 		Radio.SetRxConfig(MODEM_LORA, bw_idx,
 				  config->datarate, config->coding_rate,
 				  0, config->preamble_len, 10, false, 0,
 				  crc, false, 0, config->iq_inverted, true);
+		dev_data.rx_configured = true;
 	}
 
 	Radio.SetPublicNetwork(config->public_network);
 
+	dev_data.last_cfg = *config;
+	dev_data.last_cfg_valid = true;
+
 	modem_release(&dev_data);
 	return 0;
 }
