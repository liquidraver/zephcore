/*
 * Seeed Tracker T1000-E - nRF52840 + LR1110
 * Copyright (c) 2025 ZephCore
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Hardware:
 * - nRF52840 SoC with BLE
 * - LR1110 LoRa radio (TCXO 1.6V, DIO as RF switch)
 * - Airoha AG3335 GNSS module on UART (PAIR protocol)
 * - QMA6100P accelerometer (I2C)
 * - NTC temperature sensor (ADC)
 * - Light sensor (ADC)
 * - Buzzer with enable
 * - Battery voltage ADC
 */

/dts-v1/;
#include <nordic/nrf52840_qiaa.dtsi>
#include <nordic/nrf52840_partition.dtsi>
#include <zephyr/dt-bindings/adc/nrf-saadc.h>
#include <zephyr/dt-bindings/input/input-event-codes.h>
#include <zephyr/dt-bindings/pwm/pwm.h>
#include "t1000_e_nrf52840-pinctrl.dtsi"

/* Delete default partitions from nrf52840_partition.dtsi */
/delete-node/ &boot_partition;
/delete-node/ &slot0_partition;
/delete-node/ &slot1_partition;
/delete-node/ &storage_partition;

/ {
	model = "Seeed Tracker T1000-E";
	compatible = "seeed,t1000-e";

	chosen {
		zephyr,code-partition = &code_partition;
		zephyr,console = &cdc_acm_uart;
		zephyr,shell-uart = &cdc_acm_uart;
	};

	leds {
		compatible = "gpio-leds";

		led_green: led_0 {
			gpios = <&gpio0 24 GPIO_ACTIVE_HIGH>;
			label = "Green LED";
		};
	};

	buttons: buttons {
		compatible = "gpio-keys";

		user_button: button_0 {
			/* T1000-E button: active HIGH (pressed=VCC), no internal pull
			 * (external pull-down on board). Arduino uses INPUT, not INPUT_PULLUP. */
			gpios = <&gpio0 6 GPIO_ACTIVE_HIGH>;
			zephyr,code = <INPUT_KEY_0>;
			label = "User Button";
		};
	};

	/* Input filter: user button long-press detection (1000ms)
	 * T1000-E has only one button - long-press = enter/execute
	 * Short-press → KEY_A, Long-press → KEY_F (safe, no system side-effects) */
	user_btn_longpress {
		compatible = "zephyr,input-longpress";
		input = <&buttons>;
		input-codes = <INPUT_KEY_0>;
		short-codes = <INPUT_KEY_A>;
		long-codes = <INPUT_KEY_F>;
		long-delay-ms = <1000>;
	};

	/* Input filter: user button multi-tap detection
	 * 1 tap  (400ms wait) → KEY_1 = page next (no-op without display)
	 * 2 taps (400ms wait) → KEY_B = flood advert
	 * 3 taps (400ms wait) → KEY_D = buzzer mute toggle
	 * 4 taps (immediate)  → KEY_C = GPS on/off */
	user_btn_multitap {
		compatible = "zephcore,input-multi-tap";
		/* No 'input' phandle — listen to ALL devices.
		 * KEY_A is emitted by the longpress pseudo-device,
		 * not by &buttons, so we must not filter by device. */
		input-codes = <INPUT_KEY_A>;
		tap-codes = <INPUT_KEY_1 INPUT_KEY_B INPUT_KEY_D INPUT_KEY_C>;
		tap-delay-ms = <400>;
	};

	/* Sensor power enable - P1.06 (PIN_3V3_EN in Arduino)
	 * Powers: Battery ADC voltage divider, temperature sensor, light sensor
	 * Must be enabled before reading battery voltage or sensor ADCs
	 */
	vbat_enable: sensor_power: sensor-power {
		compatible = "regulator-fixed";
		regulator-name = "sensor-power";
		enable-gpios = <&gpio1 6 GPIO_ACTIVE_HIGH>;
		/* NOT regulator-boot-on - enabled on-demand in ZephyrBoard.cpp */
	};

	/* Battery ADC channel reference for ZephyrBoard */
	zephyr,user {
		io-channels = <&adc 0>;
		vbat-mv-multiplier = <7200>;  /* 2:1 voltage divider, 3.6V ref */
	};

	/* Buzzer on PWM0 channel 0 (P0.25) with enable on P1.05 */
	pwmbuzzer {
		compatible = "pwm-leds";
		buzzer: buzzer {
			pwms = <&pwm0 0 PWM_MSEC(20) PWM_POLARITY_NORMAL>;
		};
	};

	/* Buzzer enable pin - controls power to buzzer amplifier */
	buzzer_enable: buzzer-enable {
		compatible = "regulator-fixed";
		regulator-name = "buzzer-enable";
		enable-gpios = <&gpio1 5 GPIO_ACTIVE_HIGH>;
		/* NOT regulator-boot-on - controlled by buzzer driver */
	};

	aliases {
		led0 = &led_green;
		sw0 = &user_button;
		watchdog0 = &wdt0;
		buzzer = &buzzer;
		buzzer-enable = &buzzer_enable;
		lora0 = &lora;
	};
};

&reg0 {
	status = "okay";
};

&reg1 {
	regulator-initial-mode = <NRF5X_REG_MODE_DCDC>;
};

&adc {
	status = "okay";
	#address-cells = <1>;
	#size-cells = <0>;

	/* Battery voltage on P0.02 (AIN0) - 2x voltage divider */
	channel@0 {
		reg = <0>;
		zephyr,gain = "ADC_GAIN_1_6";
		zephyr,reference = "ADC_REF_INTERNAL";
		zephyr,acquisition-time = <ADC_ACQ_TIME(ADC_ACQ_TIME_MICROSECONDS, 10)>;
		zephyr,input-positive = <NRF_SAADC_AIN0>;
		zephyr,resolution = <12>;
	};

	/* Temperature sensor NTC on P0.31 (AIN7) */
	channel@7 {
		reg = <7>;
		zephyr,gain = "ADC_GAIN_1_6";
		zephyr,reference = "ADC_REF_INTERNAL";
		zephyr,acquisition-time = <ADC_ACQ_TIME(ADC_ACQ_TIME_MICROSECONDS, 10)>;
		zephyr,input-positive = <NRF_SAADC_AIN7>;
		zephyr,resolution = <12>;
	};

	/* Light sensor on P0.29 (AIN5) */
	channel@5 {
		reg = <5>;
		zephyr,gain = "ADC_GAIN_1_6";
		zephyr,reference = "ADC_REF_INTERNAL";
		zephyr,acquisition-time = <ADC_ACQ_TIME(ADC_ACQ_TIME_MICROSECONDS, 10)>;
		zephyr,input-positive = <NRF_SAADC_AIN5>;
		zephyr,resolution = <12>;
	};
};

&uicr {
	nfct-pins-as-gpios;
};

&gpiote {
	status = "okay";
};

&gpio0 {
	status = "okay";
};

&gpio1 {
	status = "okay";
	/* NOTE: buzzer-off gpio-hog REMOVED - buzzer enable is now managed by
	 * the regulator-fixed node (buzzer_enable). When buzzer is quiet,
	 * the regulator is disabled keeping the pin low. */
};

/* PWM0 for buzzer */
&pwm0 {
	status = "okay";
	pinctrl-0 = <&pwm0_default>;
	pinctrl-1 = <&pwm0_sleep>;
	pinctrl-names = "default", "sleep";
};

/* Airoha AG3335 GNSS on UART0 - 115200 baud
 *
 * Using gnss-nmea-generic (passive NMEA listener) instead of quectel,lc76g:
 * - Arduino reference code just listens for NMEA, never sends PAIR commands
 * - AG3335 outputs NMEA autonomously at factory defaults
 * - Eliminates 10s+ blocking resume_script timeout on PAIR command
 * - Trade-off: no gnss_set_enabled_systems() / gnss_set_fix_rate() API
 *   (AG3335 defaults are fine: GPS+GLONASS+Galileo+BeiDou, 1Hz) */
&uart0 {
	compatible = "nordic,nrf-uarte";
	status = "okay";
	current-speed = <115200>;
	pinctrl-0 = <&uart0_default>;
	pinctrl-1 = <&uart0_sleep>;
	pinctrl-names = "default", "sleep";

	gnss: gnss {
		compatible = "gnss-nmea-generic";
		/* Defer driver init — AG3335 needs GPIO power-up
		 * (GPS_EN, GPS_VRTC_EN, GPS_RESET) before NMEA output.
		 * ZephyrGPSManager handles power-up then calls device_init(). */
		zephyr,deferred-init;
	};
};

/* I2C0 for QMA6100P accelerometer + external sensors */
&i2c0 {
	compatible = "nordic,nrf-twim";
	status = "okay";
	clock-frequency = <I2C_BITRATE_FAST>;
	pinctrl-0 = <&i2c0_default>;
	pinctrl-1 = <&i2c0_sleep>;
	pinctrl-names = "default", "sleep";

	/* All supported environment & power sensors — auto-detected at runtime */
	#include "../../common/sensors-i2c.dtsi"
};

/* SPI1 for LR1110 */
&spi1 {
	compatible = "nordic,nrf-spim";
	status = "okay";
	cs-gpios = <&gpio0 12 GPIO_ACTIVE_LOW>;
	pinctrl-0 = <&spi1_default>;
	pinctrl-1 = <&spi1_sleep>;
	pinctrl-names = "default", "sleep";

	lora: lora@0 {
		compatible = "semtech,lr1110";
		reg = <0>;
		reset-gpios = <&gpio1 10 GPIO_ACTIVE_LOW>;
		busy-gpios = <&gpio0 7 GPIO_ACTIVE_HIGH>;
		dio1-gpios = <&gpio1 1 (GPIO_PULL_DOWN | GPIO_ACTIVE_HIGH)>;
		tcxo-voltage-mv = <1600>;
		tcxo-startup-delay-ms = <5>;
		rx-boosted;
		spi-max-frequency = <8000000>;
		/* RF switch: DIO5=RFSW0, DIO6=RFSW1, DIO7=RFSW2, DIO8=RFSW3 */
		rfswitch-enable = <0x0F>;
		rfswitch-standby = <0x00>;
		rfswitch-rx = <0x09>;
		rfswitch-tx = <0x0B>;
		rfswitch-tx-hp = <0x0A>;
		rfswitch-gnss = <0x04>;
	};
};

zephyr_udc0: &usbd {
	compatible = "nordic,nrf-usbd";
	status = "okay";

	cdc_acm_uart: cdc_acm_uart {
		compatible = "zephyr,cdc-acm-uart";
	};
};

/* Arduino MeshCore compatible partition layout (SoftDevice v7) */
#include "../../common/nrf52_partitions_sdv7.dtsi"
